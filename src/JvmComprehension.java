public class JvmComprehension {
/* В режиме интерпретации загрузка классов происходит "лениво":
  когда в коде встречается новый класс он загружается в систему загрузчиков классов.
  Три основных загрузчика (ClassLoader): Application, Platform, Bootstrap, - отвечают за загрузку
  различных типов классов и связаны отношением наследования (Bootstrap <- Platform <- Application)/
  Загрузка классов производится в Metaspace, где сохраняются данные о классе (имя, методы, поля) и
  константы.
  После загрузки класса начинается этап линковки, который делится на три части.
  1. Верификация байт-кода. Это статический анализ кода, выполняется один раз для класса. Система
  проверяет, нет ли ошибок в байт-коде. Например, проверяет корректность инструкций, переполнение
  стека и совместимость типов переменных.
  2. Выделение памяти под статические поля и их инициализация производится в куче (heap).
  3. Разрешение символьных ссылок — JVM подставляет ссылки на другие классы, методы и поля.
  Это происходит лениво, то есть при первом обращении к классу.   Класс инициализируется,
  и JVM может начать выполнение байт-кода методов.
*/
    // Сначала выделяется память в стеке (Stack Memory) для main.
    public static void main(String[] args) {
        int i = 1;                      // 1 в выделенный фрейм стека помещается 1
        Object o = new Object();        // 2 в куче выделяется память под экземпляр класса "о", определение которого берется из Metaspace,
                                        // и в стеке сохраняется ссылка на эту область.
        Integer ii = 2;                 // 3 в стек помещается 2
        printAll(o, i, ii);             // 4 описание метода printall() в Metaspace позволяет в стеке выделить фрейм памяти,
                                        // куда заносятся ссылка на параметр "о" и значения i и ii. Вызывается метод.                                        //
        System.out.println("finished"); // 7 В стеке выделяется фрейм для System.out.println(), а куче образуется фрейм String
                                        // со значением "finished", ссылка на который помещается во фрейм стека. Метод вызывается
                                        // и после отработки фрейм удаляется из стека.
    }
    /*
      При завершении программы из стека удаляется фрейм, связанный с main. Оставшиеся в куче объекты ("о" и два String) удаляются сборщиком мусора.
      Классы main и "о" удаляются из Metaspace.
    */
    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5 в стек в область метода помещается 700
        System.out.println(o.toString() + i + ii);  // 6 в стеке создается фрейм для метода o.toString(), а в куче выделяется памать под переменную
                                                    // String, представляющую результат этого метода. Вызывается метод и фрейм удаляется из стека.
                                                    // Далее в стеке выделяется фрейм для System.out.println, где сохраняется ссылка на резудьтат
                                                    // o.toString() и значения i и ii. Метод вызывается и после отработки соответствующий фрейм
                                                    // удаляется из стека.
    }
}